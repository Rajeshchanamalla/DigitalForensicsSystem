/**
 * PDF Report Generation
 * Uses PDFKit
 */

const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

/**
 * Generate evidence report PDF
 */
function generateEvidenceReport(evidence, chainOfCustody, verifications, outputPath) {
    return new Promise((resolve, reject) => {
        try {
            const doc = new PDFDocument({ margin: 50 });
            const stream = fs.createWriteStream(outputPath);
            doc.pipe(stream);

            // Header
            doc.fontSize(20).text('Digital Forensic Evidence Report', { align: 'center' });
            doc.moveDown();
            doc.fontSize(12).text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });
            doc.moveDown(2);

            // Evidence Details
            doc.fontSize(16).text('Evidence Details', { underline: true });
            doc.moveDown(0.5);
            doc.fontSize(10);
            doc.text(`Evidence ID: ${evidence.id}`);
            doc.text(`Case ID: ${evidence.caseId}`);
            doc.text(`File Name: ${evidence.fileName}`);
            doc.text(`File Size: ${formatFileSize(evidence.fileSize)}`);
            doc.text(`File Type: ${evidence.fileType || 'N/A'}`);
            doc.text(`SHA-256 Hash: ${evidence.evidenceHash}`);
            doc.text(`IPFS CID: ${evidence.ipfsCID}`);
            doc.text(`Investigator: ${evidence.investigatorId}`);
            doc.text(`Status: ${evidence.status.toUpperCase()}`);
            doc.text(`Category: ${evidence.category || 'N/A'}`);
            doc.text(`Tags: ${evidence.tags || 'N/A'}`);
            doc.text(`Created At: ${evidence.createdAtReadable || evidence.createdAt}`);
            if (evidence.verifiedAt) {
                doc.text(`Verified At: ${evidence.verifiedAt}`);
                doc.text(`Verified By: ${evidence.verifiedBy || 'N/A'}`);
            }
            if (evidence.description) {
                doc.moveDown(0.5);
                doc.text(`Description: ${evidence.description}`);
            }
            doc.moveDown(2);

            // Chain of Custody
            if (chainOfCustody && chainOfCustody.length > 0) {
                doc.fontSize(16).text('Chain of Custody', { underline: true });
                doc.moveDown(0.5);
                doc.fontSize(10);
                
                chainOfCustody.forEach((entry, index) => {
                    doc.text(`${index + 1}. ${entry.action.toUpperCase()} - ${entry.performedBy} (${entry.role})`);
                    doc.text(`   ${entry.timestampReadable || entry.timestamp}`);
                    if (entry.description) {
                        doc.text(`   ${entry.description}`);
                    }
                    doc.moveDown(0.3);
                });
                doc.moveDown(2);
            }

            // Verification History
            if (verifications && verifications.length > 0) {
                doc.fontSize(16).text('Verification History', { underline: true });
                doc.moveDown(0.5);
                doc.fontSize(10);
                
                verifications.forEach((verification, index) => {
                    const status = verification.isValid ? 'VALID' : 'INVALID';
                    doc.text(`${index + 1}. Verification ${status} - ${verification.verifiedBy}`);
                    doc.text(`   Verified At: ${verification.verifiedAtReadable || verification.verifiedAt}`);
                    doc.text(`   Computed Hash: ${verification.verificationHash}`);
                    doc.text(`   Stored Hash: ${verification.storedHash}`);
                    if (verification.verificationNotes) {
                        doc.text(`   Notes: ${verification.verificationNotes}`);
                    }
                    doc.moveDown(0.3);
                });
                doc.moveDown(2);
            }

            // Footer
            doc.fontSize(8).text(
                'This report was generated by the Digital Forensic Evidence Management System.',
                { align: 'center' }
            );

            doc.end();
            
            stream.on('finish', () => {
                resolve(outputPath);
            });
            
            stream.on('error', (error) => {
                reject(error);
            });
        } catch (error) {
            reject(error);
        }
    });
}

/**
 * Generate case summary report
 */
function generateCaseReport(caseId, evidenceList, outputPath) {
    return new Promise((resolve, reject) => {
        try {
            const doc = new PDFDocument({ margin: 50 });
            const stream = fs.createWriteStream(outputPath);
            doc.pipe(stream);

            // Header
            doc.fontSize(20).text(`Case Report: ${caseId}`, { align: 'center' });
            doc.moveDown();
            doc.fontSize(12).text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });
            doc.moveDown(2);

            // Summary
            doc.fontSize(16).text('Case Summary', { underline: true });
            doc.moveDown(0.5);
            doc.fontSize(10);
            doc.text(`Total Evidence: ${evidenceList.length}`);
            const statusCounts = evidenceList.reduce((acc, e) => {
                acc[e.status] = (acc[e.status] || 0) + 1;
                return acc;
            }, {});
            doc.text(`Status Breakdown:`);
            Object.entries(statusCounts).forEach(([status, count]) => {
                doc.text(`  - ${status}: ${count}`);
            });
            doc.moveDown(2);

            // Evidence List
            doc.fontSize(16).text('Evidence List', { underline: true });
            doc.moveDown(0.5);
            doc.fontSize(10);
            
            evidenceList.forEach((evidence, index) => {
                doc.text(`${index + 1}. ${evidence.fileName}`);
                doc.text(`   ID: ${evidence.id} | Status: ${evidence.status} | Hash: ${evidence.evidenceHash.substring(0, 16)}...`);
                doc.moveDown(0.3);
            });

            doc.end();
            
            stream.on('finish', () => {
                resolve(outputPath);
            });
            
            stream.on('error', (error) => {
                reject(error);
            });
        } catch (error) {
            reject(error);
        }
    });
}

/**
 * Format file size
 */
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

module.exports = {
    generateEvidenceReport,
    generateCaseReport
};

